"use client";

import { createContext, useContext, ReactNode, useEffect, useState, useMemo } from "react";
import { useChat as useAIChat } from "@ai-sdk/react";
import { UIMessage, DefaultChatTransport } from "ai";
import { useFileSystem } from "./file-system-context";
import { setHasAnonWork } from "@/lib/anon-work-tracker";

interface ChatContextProps {
  projectId?: string;
  initialMessages?: UIMessage[];
}

interface ChatContextType {
  messages: UIMessage[];
  input: string;
  handleInputChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void;
  handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  status: string;
}

const ChatContext = createContext<ChatContextType | undefined>(undefined);

export function ChatProvider({
  children,
  projectId,
  initialMessages = [],
}: ChatContextProps & { children: ReactNode }) {
  const { fileSystem, handleToolCall } = useFileSystem();

  const [input, setInput] = useState("");

  // Create transport with body included
  const transport = useMemo(
    () =>
      new DefaultChatTransport({
        api: "/api/chat",
        body: {
          files: fileSystem.serialize(),
          projectId,
        },
      }),
    [fileSystem, projectId]
  );

  const { messages, sendMessage, status } = useAIChat({
    messages: initialMessages,

    onToolCall: ({ toolCall }) => {
      // Adapt the new toolCall format (uses 'input') to the old format (uses 'args')
      handleToolCall({
        toolName: toolCall.toolName,
        args: (toolCall as any).input ?? (toolCall as any).args,
      });
    },

    transport,
  });

  // Create handleSubmit wrapper that calls sendMessage
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (input.trim()) {
      sendMessage({
        parts: [{ type: "text", text: input }],
      });
      setInput("");
    }
  };

  // Track anonymous work
  useEffect(() => {
    if (!projectId && messages.length > 0) {
      setHasAnonWork(messages, fileSystem.serialize());
    }
  }, [messages, fileSystem, projectId]);

  return (
    <ChatContext.Provider
      value={{
        messages,
        input,
        handleInputChange: (e) => setInput(e.target.value),
        handleSubmit,
        status,
      }}
    >
      {children}
    </ChatContext.Provider>
  );
}

export function useChat() {
  const context = useContext(ChatContext);
  if (context === undefined) {
    throw new Error("useChat must be used within a ChatProvider");
  }
  return context;
}
